# 语音实时对话文本显示功能测试计划

## 测试环境准备

1. **启动后端服务**（yychat项目）
   ```bash
   cd /Users/zhangjun/CursorProjects/yychat
   python app.py
   ```

2. **启动前端服务**（yyAsistant项目）
   ```bash
   cd /Users/zhangjun/CursorProjects/yyAsistant
   python app.py
   ```

3. **打开浏览器**
   - 访问：http://localhost:8050
   - 登录系统
   - 进入 `/core/chat` 页面

## 测试用例

### 阶段5.1：功能测试

#### 测试1：录音聊天功能验证
**目标**：验证录音聊天功能未受影响，场景区分正确

**步骤**：
1. 进入聊天页面
2. 点击录音按钮开始录音
3. 说话后停止录音
4. 观察聊天历史是否正常显示转录文本

**预期结果**：
- ✅ 录音聊天正常工作
- ✅ 转录文本出现在聊天历史中
- ✅ 语音实时对话文本显示面板不显示（因为场景是 `voice_recording`）
- ✅ 控制台日志显示："收到录音聊天转录结果，跳过语音实时对话处理"

#### 测试2：语音实时对话功能验证
**目标**：验证语音实时对话功能正常，文本显示正确

**步骤**：
1. 进入聊天页面
2. 点击"开始实时对话"按钮
3. 观察悬浮面板是否显示（应在聊天历史上方）
4. 说话后观察文本是否实时显示在悬浮面板中
5. 停止对话
6. 观察悬浮面板是否隐藏

**预期结果**：
- ✅ 语音实时对话正常启动
- ✅ 悬浮面板在对话开始时显示（`voice-call-text-display`）
- ✅ 转录文本实时显示在悬浮面板中（整句显示，非流式）
- ✅ 用户消息和AI回复都正确显示
- ✅ 对话停止后，悬浮面板隐藏
- ✅ 控制台日志显示："收到语音实时对话转录结果"
- ✅ 控制台日志显示："语音实时对话：使用独立显示逻辑"

#### 测试3：场景切换验证
**目标**：验证不同场景的消息不会互相干扰

**步骤**：
1. 先进行一次录音聊天
2. 然后进行一次语音实时对话
3. 再回到录音聊天
4. 观察两种场景的消息是否正确分离

**预期结果**：
- ✅ 录音聊天的消息只出现在聊天历史中
- ✅ 语音实时对话的消息只出现在悬浮面板中
- ✅ 场景切换时不会出现消息混淆
- ✅ 控制台日志正确显示场景类型

#### 测试4：消息保存功能验证（可选）
**目标**：验证消息保存功能正常

**前置条件**：
- 需要修改配置：`VoiceConfig.VOICE_CALL_SAVE_TO_DATABASE = True`

**步骤**：
1. 修改 `configs/voice_config.py`，设置 `VOICE_CALL_SAVE_TO_DATABASE = True`
2. 重启前端服务
3. 进行一次语音实时对话
4. 停止对话
5. 检查数据库，查看消息是否保存

**预期结果**：
- ✅ 对话结束时，消息自动保存到数据库
- ✅ 数据库中的 `conv_memory` 字段包含消息列表
- ✅ `source` 字段为 `'voice_call'`
- ✅ 控制台日志显示："✅ 语音实时对话消息已保存到数据库"

### 阶段5.2：性能测试

#### 测试5：累积更新机制验证
**目标**：验证防抖机制正常工作，消息不丢失

**步骤**：
1. 开始语音实时对话
2. 快速连续说话多次（在500ms内多次触发转录）
3. 观察消息是否正确累积显示

**预期结果**：
- ✅ 所有消息都正确显示，没有丢失
- ✅ 消息在500ms内批量更新（防抖生效）
- ✅ 控制台日志显示正确的累积更新次数

#### 测试6：消息数量限制验证
**目标**：验证消息数量限制生效

**步骤**：
1. 开始语音实时对话
2. 进行超过50次对话（Store限制）
3. 观察消息数量是否正确限制

**预期结果**：
- ✅ Store中最多保存50条消息（`max_messages: 50`）
- ✅ 超出限制时，旧消息被删除
- ✅ UI中最多显示10条消息（DOM限制）
- ✅ 滚动到底部显示最新消息

#### 测试7：防抖性能验证
**目标**：验证防抖机制不影响性能

**步骤**：
1. 打开浏览器开发者工具（Performance）
2. 开始语音实时对话
3. 快速说话多次
4. 观察CPU和内存使用情况

**预期结果**：
- ✅ CPU使用率正常，无卡顿
- ✅ 内存使用稳定，无明显泄漏
- ✅ DOM更新频率合理（约每500ms一次）
- ✅ 界面流畅，无明显延迟

### 阶段5.3：集成测试

#### 测试8：并发操作验证
**目标**：验证并发操作不会导致冲突

**步骤**：
1. 开始语音实时对话
2. 同时进行文本聊天（发送一条文本消息）
3. 观察两种操作是否正常

**预期结果**：
- ✅ 语音实时对话继续正常
- ✅ 文本聊天正常工作
- ✅ 消息正确显示在各自的位置
- ✅ 无错误或异常

#### 测试9：页面刷新验证
**目标**：验证页面刷新后功能正常

**步骤**：
1. 进行一次语音实时对话
2. 刷新页面（F5）
3. 重新开始语音实时对话
4. 观察功能是否正常

**预期结果**：
- ✅ 页面刷新后功能正常
- ✅ WebSocket连接正常重建
- ✅ 文本显示正常
- ✅ 配置项正确加载

#### 测试10：错误处理验证
**目标**：验证错误处理机制正常工作

**步骤**：
1. 在语音实时对话过程中，断开网络
2. 观察错误处理
3. 恢复网络后，观察自动重连

**预期结果**：
- ✅ 错误被正确捕获和记录
- ✅ 用户界面显示友好提示
- ✅ 网络恢复后自动重连
- ✅ 功能恢复正常

#### 测试11：关闭按钮功能验证
**目标**：验证关闭按钮正常工作

**步骤**：
1. 开始语音实时对话
2. 点击悬浮面板右上角的关闭按钮
3. 观察面板是否隐藏
4. 继续对话，观察面板是否重新显示

**预期结果**：
- ✅ 点击关闭按钮后，面板隐藏（`display: none`）
- ✅ 对话继续正常进行
- ✅ 当新消息到达时，面板可以重新显示（如果需要）

## 测试检查清单

### 前端检查
- [ ] 控制台无JavaScript错误
- [ ] 所有日志正确输出
- [ ] Store数据正确更新
- [ ] UI显示正确
- [ ] 性能指标正常

### 后端检查
- [ ] 服务器日志无错误
- [ ] WebSocket连接正常
- [ ] `scenario` 字段正确设置
- [ ] API端点响应正常（如果测试保存功能）

### 数据库检查（如果测试保存功能）
- [ ] 消息正确保存
- [ ] `source` 字段正确
- [ ] 消息格式正确

## 已知问题和注意事项

1. **配置项**：
   - `VOICE_CALL_SHOW_TRANSCRIPTION`：控制是否显示文本（默认：True）
   - `VOICE_CALL_SAVE_TO_DATABASE`：控制是否保存（默认：False）
   - `VOICE_CALL_MAX_DISPLAY_MESSAGES`：Store最大消息数（默认：50）
   - `VOICE_CALL_TRANSCRIPTION_DEBOUNCE`：防抖时间（默认：500ms）

2. **UI限制**：
   - Store最多保存50条消息
   - UI最多显示10条消息（DOM性能优化）

3. **场景区分**：
   - `voice_recording`：录音聊天（显示在聊天历史）
   - `voice_call`：语音实时对话（显示在悬浮面板）

## 测试报告模板

测试完成后，请填写以下信息：

```
测试日期：_________
测试人员：_________
测试环境：_________

功能测试结果：
- 录音聊天：✅/❌
- 语音实时对话：✅/❌
- 场景切换：✅/❌
- 消息保存：✅/❌

性能测试结果：
- 累积更新机制：✅/❌
- 消息数量限制：✅/❌
- 防抖性能：✅/❌

集成测试结果：
- 并发操作：✅/❌
- 页面刷新：✅/❌
- 错误处理：✅/❌
- 关闭按钮：✅/❌

发现问题：
1. _________
2. _________

测试结论：
_________
```

