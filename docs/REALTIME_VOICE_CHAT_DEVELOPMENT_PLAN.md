# è¯­éŸ³å®æ—¶å¯¹è¯åŠŸèƒ½å¼€å‘è®¡åˆ’

**é¡¹ç›®**: YYChat + YYAssistant è¯­éŸ³å®æ—¶å¯¹è¯åŠŸèƒ½å¼€å‘  
**ç‰ˆæœ¬**: v1.0  
**æ—¥æœŸ**: 2025å¹´1æœˆ15æ—¥  
**ç›®æ ‡**: å®ç°å®Œæ•´çš„è¯­éŸ³å®æ—¶å¯¹è¯åŠŸèƒ½

---

## ğŸ“‹ é¡¹ç›®æ¦‚è¿°

### å½“å‰çŠ¶æ€åˆ†æ

#### âœ… å·²å®ŒæˆåŠŸèƒ½
**åç«¯ (YYChat)**:
- âœ… WebSocketé€šä¿¡å±‚ (100%)
- âœ… éŸ³é¢‘å¤„ç†æœåŠ¡ (STT/TTS) (100%)
- âœ… å®æ—¶æ¶ˆæ¯å¤„ç† (100%)
- âœ… æµå¼TTSç®¡ç†å™¨ (100%)
- âœ… éŸ³é¢‘ç¼“å­˜ç³»ç»Ÿ (100%)
- âœ… è¯­éŸ³äººæ ¼åŒ–æœåŠ¡ (100%)

**å‰ç«¯ (YYAssistant)**:
- âœ… è¯­éŸ³å½•åˆ¶åŠŸèƒ½ (100%)
- âœ… è¯­éŸ³æ’­æ”¾åŠŸèƒ½ (100%)
- âœ… WebSocketè¿æ¥ç®¡ç† (100%)
- âœ… ç»Ÿä¸€æŒ‰é’®çŠ¶æ€ç®¡ç† (100%)
- âœ… è¯­éŸ³é…ç½®ç³»ç»Ÿ (100%)

#### âš ï¸ éƒ¨åˆ†å®ŒæˆåŠŸèƒ½
**åç«¯**:
- âš ï¸ å®æ—¶éŸ³é¢‘æµå¤„ç† (30%) - ç¼ºå°‘VADå’Œæµå¼å¤„ç†
- âš ï¸ è¿æ¥æ± ç®¡ç† (20%) - åªæœ‰åŸºç¡€æ¡†æ¶
- âš ï¸ é”™è¯¯æ¢å¤æœºåˆ¶ (40%) - åŸºç¡€é”™è¯¯å¤„ç†

**å‰ç«¯**:
- âš ï¸ å®æ—¶UIæ›´æ–° (60%) - æŒ‰é’®çŠ¶æ€ç®¡ç†æœ‰é—®é¢˜
- âš ï¸ éŸ³é¢‘å¯è§†åŒ– (0%) - æœªå®ç°
- âš ï¸ å®æ—¶å¯¹è¯ç•Œé¢ (0%) - æœªå®ç°

#### âŒ æœªå®ŒæˆåŠŸèƒ½
**åç«¯**:
- âŒ è¯­éŸ³æ´»åŠ¨æ£€æµ‹ (VAD)
- âŒ å®æ—¶éŸ³é¢‘æµç¼“å†²
- âŒ ä½å»¶è¿Ÿå“åº”ä¼˜åŒ–
- âŒ è¿æ¥æ± ç®¡ç†
- âŒ æ€§èƒ½ç›‘æ§

**å‰ç«¯**:
- âŒ å®æ—¶å¯¹è¯ç•Œé¢
- âŒ éŸ³é¢‘å¯è§†åŒ–
- âŒ å®æ—¶çŠ¶æ€æŒ‡ç¤ºå™¨
- âŒ è¯­éŸ³è®¾ç½®ç•Œé¢
- âŒ é”™è¯¯å¤„ç†ç•Œé¢

---

## ğŸ¯ å¼€å‘ç›®æ ‡

### æ ¸å¿ƒç›®æ ‡
1. **å®ç°çœŸæ­£çš„å®æ—¶è¯­éŸ³å¯¹è¯**ï¼šç”¨æˆ·è¯´è¯æ—¶AIå®æ—¶å“åº”
2. **ä¼˜åŒ–éŸ³é¢‘å¤„ç†å»¶è¿Ÿ**ï¼šä»å½“å‰3-5ç§’é™ä½åˆ°1-2ç§’
3. **å®Œå–„ç”¨æˆ·ä½“éªŒ**ï¼šç›´è§‚çš„å®æ—¶å¯¹è¯ç•Œé¢å’ŒçŠ¶æ€æŒ‡ç¤º
4. **æé«˜ç³»ç»Ÿç¨³å®šæ€§**ï¼šé”™è¯¯æ¢å¤å’Œè¿æ¥ç®¡ç†

### æŠ€æœ¯æŒ‡æ ‡
- **éŸ³é¢‘å»¶è¿Ÿ**: < 2ç§’ (ä»å½•éŸ³åˆ°æ’­æ”¾)
- **è¿æ¥ç¨³å®šæ€§**: > 99% å¯ç”¨æ€§
- **å¹¶å‘æ”¯æŒ**: 50+ åŒæ—¶è¿æ¥
- **éŸ³é¢‘è´¨é‡**: 16kHz, å•å£°é“, WebMæ ¼å¼

---

## ğŸš€ å¼€å‘è®¡åˆ’

### Phase 1: åç«¯å®æ—¶éŸ³é¢‘æµå¤„ç† (ç¬¬1-2å‘¨)

#### 1.1 è¯­éŸ³æ´»åŠ¨æ£€æµ‹ (VAD) å®ç°
**ç›®æ ‡**: å®ç°æ™ºèƒ½è¯­éŸ³æ´»åŠ¨æ£€æµ‹ï¼Œè‡ªåŠ¨è¯†åˆ«ç”¨æˆ·å¼€å§‹/åœæ­¢è¯´è¯

**ä»»åŠ¡æ¸…å•**:
- [ ] **å®‰è£…VADä¾èµ–**
  ```bash
  pip install webrtcvad
  pip install pyaudio  # ç”¨äºéŸ³é¢‘å¤„ç†
  ```

- [ ] **åˆ›å»ºVADå¤„ç†å™¨**
  ```python
  # core/voice_activity_detector.py
  import webrtcvad
  import numpy as np
  
  class VoiceActivityDetector:
      def __init__(self, aggressiveness=2):
          self.vad = webrtcvad.Vad(aggressiveness)
          self.sample_rate = 16000
          self.frame_duration = 30  # 30ms
          self.frame_size = int(self.sample_rate * self.frame_duration / 1000)
          
      def detect_speech(self, audio_data: bytes) -> bool:
          """æ£€æµ‹éŸ³é¢‘æ•°æ®ä¸­æ˜¯å¦åŒ…å«è¯­éŸ³"""
          if len(audio_data) < self.frame_size * 2:
              return False
          return self.vad.is_speech(audio_data, self.sample_rate)
      
      def process_audio_stream(self, audio_chunks: List[bytes]) -> List[bool]:
          """å¤„ç†éŸ³é¢‘æµï¼Œè¿”å›æ¯å¸§çš„è¯­éŸ³æ£€æµ‹ç»“æœ"""
          results = []
          for chunk in audio_chunks:
              if len(chunk) >= self.frame_size * 2:
                  results.append(self.detect_speech(chunk))
              else:
                  results.append(False)
          return results
  ```

- [ ] **é›†æˆVADåˆ°å®æ—¶å¤„ç†å™¨**
  ```python
  # core/realtime_handler.py (ä¿®æ”¹)
  from core.voice_activity_detector import VoiceActivityDetector
  
  class RealtimeMessageHandler:
      def __init__(self, ...):
          self.vad = VoiceActivityDetector()
          self.audio_buffers = {}  # å®¢æˆ·ç«¯éŸ³é¢‘ç¼“å†²
          self.speech_segments = {}  # è¯­éŸ³æ®µæ£€æµ‹
      
      async def _handle_audio_stream(self, client_id: str, audio_chunk: bytes):
          """å¤„ç†å®æ—¶éŸ³é¢‘æµ"""
          # 1. æ·»åŠ åˆ°éŸ³é¢‘ç¼“å†²
          if client_id not in self.audio_buffers:
              self.audio_buffers[client_id] = []
          self.audio_buffers[client_id].append(audio_chunk)
          
          # 2. æ£€æµ‹è¯­éŸ³æ´»åŠ¨
          is_speech = self.vad.detect_speech(audio_chunk)
          
          # 3. æ›´æ–°è¯­éŸ³æ®µçŠ¶æ€
          if client_id not in self.speech_segments:
              self.speech_segments[client_id] = {
                  'is_speaking': False,
                  'speech_start': None,
                  'silence_count': 0
              }
          
          segment = self.speech_segments[client_id]
          
          if is_speech:
              if not segment['is_speaking']:
                  segment['is_speaking'] = True
                  segment['speech_start'] = time.time()
                  await self._handle_speech_start(client_id)
              segment['silence_count'] = 0
          else:
              if segment['is_speaking']:
                  segment['silence_count'] += 1
                  # è¿ç»­é™éŸ³è¶…è¿‡é˜ˆå€¼ï¼Œè®¤ä¸ºè¯­éŸ³ç»“æŸ
                  if segment['silence_count'] > 10:  # 300msé™éŸ³
                      await self._handle_speech_end(client_id)
      
      async def _handle_speech_start(self, client_id: str):
          """å¤„ç†è¯­éŸ³å¼€å§‹"""
          await websocket_manager.send_message(client_id, {
              "type": "speech_started",
              "timestamp": time.time(),
              "client_id": client_id
          })
      
      async def _handle_speech_end(self, client_id: str):
          """å¤„ç†è¯­éŸ³ç»“æŸï¼Œå¼€å§‹å¤„ç†"""
          segment = self.speech_segments[client_id]
          segment['is_speaking'] = False
          
          # è·å–å®Œæ•´çš„è¯­éŸ³æ•°æ®
          audio_data = b''.join(self.audio_buffers[client_id])
          
          # æ¸…ç©ºç¼“å†²
          self.audio_buffers[client_id] = []
          
          # å¼€å§‹å¤„ç†è¯­éŸ³
          await self._process_complete_speech(client_id, audio_data)
  ```

#### 1.2 å®æ—¶éŸ³é¢‘æµç¼“å†²ç®¡ç†
**ç›®æ ‡**: å®ç°é«˜æ•ˆçš„éŸ³é¢‘æµç¼“å†²å’Œåˆ†æ®µå¤„ç†

**ä»»åŠ¡æ¸…å•**:
- [ ] **åˆ›å»ºéŸ³é¢‘æµç¼“å†²å™¨**
  ```python
  # core/audio_stream_buffer.py
  import asyncio
  from collections import deque
  from typing import List, Optional
  
  class AudioStreamBuffer:
      def __init__(self, max_size: int = 100, chunk_duration: float = 0.1):
          self.max_size = max_size
          self.chunk_duration = chunk_duration
          self.buffers = {}  # client_id -> deque
          self.locks = {}    # client_id -> asyncio.Lock
      
      async def add_chunk(self, client_id: str, audio_chunk: bytes):
          """æ·»åŠ éŸ³é¢‘å—åˆ°ç¼“å†²"""
          if client_id not in self.buffers:
              self.buffers[client_id] = deque(maxlen=self.max_size)
              self.locks[client_id] = asyncio.Lock()
          
          async with self.locks[client_id]:
              self.buffers[client_id].append({
                  'data': audio_chunk,
                  'timestamp': time.time()
              })
      
      async def get_complete_audio(self, client_id: str) -> Optional[bytes]:
          """è·å–å®Œæ•´çš„éŸ³é¢‘æ•°æ®"""
          if client_id not in self.buffers:
              return None
          
          async with self.locks[client_id]:
              if not self.buffers[client_id]:
                  return None
              
              # åˆå¹¶æ‰€æœ‰éŸ³é¢‘å—
              audio_data = b''.join(chunk['data'] for chunk in self.buffers[client_id])
              self.buffers[client_id].clear()
              return audio_data
      
      async def clear_buffer(self, client_id: str):
          """æ¸…ç©ºæŒ‡å®šå®¢æˆ·ç«¯çš„ç¼“å†²"""
          if client_id in self.buffers:
              async with self.locks[client_id]:
                  self.buffers[client_id].clear()
  ```

#### 1.3 ä½å»¶è¿Ÿå“åº”ä¼˜åŒ–
**ç›®æ ‡**: ä¼˜åŒ–éŸ³é¢‘å¤„ç†ç®¡é“ï¼Œå®ç°ä½å»¶è¿Ÿå“åº”

**ä»»åŠ¡æ¸…å•**:
- [ ] **å®ç°å¹¶è¡ŒéŸ³é¢‘å¤„ç†**
  ```python
  # core/parallel_audio_processor.py
  import asyncio
  from concurrent.futures import ThreadPoolExecutor
  
  class ParallelAudioProcessor:
      def __init__(self, max_workers: int = 4):
          self.executor = ThreadPoolExecutor(max_workers=max_workers)
          self.processing_tasks = {}  # client_id -> task
      
      async def process_audio_async(self, client_id: str, audio_data: bytes):
          """å¼‚æ­¥å¤„ç†éŸ³é¢‘æ•°æ®"""
          # å¦‚æœè¯¥å®¢æˆ·ç«¯å·²æœ‰å¤„ç†ä»»åŠ¡ï¼Œå–æ¶ˆæ—§ä»»åŠ¡
          if client_id in self.processing_tasks:
              self.processing_tasks[client_id].cancel()
          
          # åˆ›å»ºæ–°çš„å¤„ç†ä»»åŠ¡
          task = asyncio.create_task(
              self._process_audio_in_thread(client_id, audio_data)
          )
          self.processing_tasks[client_id] = task
          
          try:
              result = await task
              return result
          except asyncio.CancelledError:
              log.info(f"éŸ³é¢‘å¤„ç†ä»»åŠ¡è¢«å–æ¶ˆ: {client_id}")
              return None
          finally:
              if client_id in self.processing_tasks:
                  del self.processing_tasks[client_id]
      
      async def _process_audio_in_thread(self, client_id: str, audio_data: bytes):
          """åœ¨çº¿ç¨‹æ± ä¸­å¤„ç†éŸ³é¢‘"""
          loop = asyncio.get_event_loop()
          return await loop.run_in_executor(
              self.executor,
              self._process_audio_sync,
              client_id,
              audio_data
          )
      
      def _process_audio_sync(self, client_id: str, audio_data: bytes):
          """åŒæ­¥éŸ³é¢‘å¤„ç†ï¼ˆåœ¨çº¿ç¨‹ä¸­è¿è¡Œï¼‰"""
          try:
              # 1. è¯­éŸ³è½¬æ–‡æœ¬
              text = asyncio.run(audio_service.transcribe_audio(audio_data))
              
              # 2. å¤„ç†æ–‡æœ¬ï¼ˆè°ƒç”¨AIï¼‰
              response = asyncio.run(self._get_ai_response(text, client_id))
              
              # 3. æ–‡æœ¬è½¬è¯­éŸ³
              audio_response = asyncio.run(
                  audio_service.synthesize_speech(response)
              )
              
              return {
                  'text': text,
                  'response': response,
                  'audio': audio_response
              }
          except Exception as e:
              log.error(f"éŸ³é¢‘å¤„ç†å¤±è´¥: {e}")
              return None
  ```

### Phase 2: å‰ç«¯å®æ—¶å¯¹è¯ç•Œé¢ (ç¬¬3-4å‘¨)

#### 2.1 å®æ—¶å¯¹è¯ç•Œé¢ç»„ä»¶
**ç›®æ ‡**: åˆ›å»ºç›´è§‚çš„å®æ—¶è¯­éŸ³å¯¹è¯ç•Œé¢

**ä»»åŠ¡æ¸…å•**:
- [ ] **åˆ›å»ºå®æ—¶å¯¹è¯ç»„ä»¶**
  ```python
  # components/realtime_voice_chat.py
  import dash
  from dash import html, dcc
  import feffery_antd_components as fac
  
  class RealtimeVoiceChatComponent:
      def render(self):
          return html.Div([
              # å®æ—¶å¯¹è¯æ§åˆ¶é¢æ¿
              fac.AntdCard([
                  fac.AntdRow([
                      fac.AntdCol([
                          fac.AntdButton(
                              id="realtime-start-btn",
                              type="primary",
                              icon="microphone",
                              children="å¼€å§‹å®æ—¶å¯¹è¯",
                              size="large",
                              style={"width": "100%", "height": "60px"}
                          )
                      ], span=8),
                      fac.AntdCol([
                          fac.AntdButton(
                              id="realtime-stop-btn",
                              type="default",
                              icon="stop",
                              children="åœæ­¢å¯¹è¯",
                              size="large",
                              disabled=True,
                              style={"width": "100%", "height": "60px"}
                          )
                      ], span=8),
                      fac.AntdCol([
                          fac.AntdButton(
                              id="realtime-mute-btn",
                              type="default",
                              icon="sound",
                              children="é™éŸ³",
                              size="large",
                              style={"width": "100%", "height": "60px"}
                          )
                      ], span=8)
                  ]),
                  
                  # å®æ—¶çŠ¶æ€æŒ‡ç¤ºå™¨
                  html.Div([
                      fac.AntdBadge(
                          dot=True,
                          color="red",
                          children="æ­£åœ¨ç›‘å¬"
                      ),
                      html.Span(" å®æ—¶è¯­éŸ³å¯¹è¯æ¨¡å¼", 
                               style={"marginLeft": "10px", "fontSize": "16px"})
                  ], id="realtime-status", style={"marginTop": "15px", "textAlign": "center"})
                  
              ], title="å®æ—¶è¯­éŸ³å¯¹è¯", style={"marginBottom": "20px"}),
              
              # å¯¹è¯å†å²
              html.Div([
                  html.H4("å¯¹è¯å†å²"),
                  html.Div(id="realtime-chat-history", style={
                      "height": "300px",
                      "overflowY": "auto",
                      "border": "1px solid #d9d9d9",
                      "borderRadius": "6px",
                      "padding": "10px"
                  })
              ]),
              
              # éŸ³é¢‘å¯è§†åŒ–
              html.Div([
                  html.H4("éŸ³é¢‘å¯è§†åŒ–"),
                  html.Canvas(
                      id="audio-visualizer",
                      width=800,
                      height=200,
                      style={
                          "border": "1px solid #d9d9d9",
                          "borderRadius": "6px",
                          "marginTop": "10px"
                      }
                  )
              ]),
              
              # éšè—çš„å­˜å‚¨ç»„ä»¶
              dcc.Store(id="realtime-conversation-store", data=[]),
              dcc.Store(id="realtime-audio-store", data=None),
              dcc.Store(id="realtime-status-store", data={"status": "idle"})
          ])
  ```

#### 2.2 éŸ³é¢‘å¯è§†åŒ–ç»„ä»¶
**ç›®æ ‡**: å®ç°å®æ—¶éŸ³é¢‘æ³¢å½¢å’Œé¢‘è°±æ˜¾ç¤º

**ä»»åŠ¡æ¸…å•**:
- [ ] **åˆ›å»ºéŸ³é¢‘å¯è§†åŒ–å™¨**
  ```javascript
  // assets/js/audio_visualizer.js
  class AudioVisualizer {
      constructor(canvasId) {
          this.canvas = document.getElementById(canvasId);
          this.ctx = this.canvas.getContext('2d');
          this.animationId = null;
          this.audioContext = null;
          this.analyser = null;
          this.dataArray = null;
          this.isVisualizing = false;
      }
      
      async startVisualization(audioStream) {
          try {
              this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
              this.analyser = this.audioContext.createAnalyser();
              const source = this.audioContext.createMediaStreamSource(audioStream);
              
              source.connect(this.analyser);
              this.analyser.fftSize = 256;
              this.dataArray = new Uint8Array(this.analyser.frequencyBinCount);
              
              this.isVisualizing = true;
              this.draw();
              
          } catch (error) {
              console.error('éŸ³é¢‘å¯è§†åŒ–å¯åŠ¨å¤±è´¥:', error);
          }
      }
      
      draw() {
          if (!this.isVisualizing) return;
          
          this.animationId = requestAnimationFrame(() => this.draw());
          
          this.analyser.getByteFrequencyData(this.dataArray);
          
          // æ¸…ç©ºç”»å¸ƒ
          this.ctx.fillStyle = 'rgb(0, 0, 0)';
          this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
          
          // ç»˜åˆ¶é¢‘è°±
          const barWidth = (this.canvas.width / this.dataArray.length) * 2.5;
          let barHeight;
          let x = 0;
          
          for (let i = 0; i < this.dataArray.length; i++) {
              barHeight = (this.dataArray[i] / 255) * this.canvas.height;
              
              // æ ¹æ®é¢‘ç‡è®¾ç½®é¢œè‰²
              const hue = (i / this.dataArray.length) * 360;
              this.ctx.fillStyle = `hsl(${hue}, 100%, 50%)`;
              
              this.ctx.fillRect(x, this.canvas.height - barHeight, barWidth, barHeight);
              x += barWidth + 1;
          }
      }
      
      stopVisualization() {
          this.isVisualizing = false;
          if (this.animationId) {
              cancelAnimationFrame(this.animationId);
          }
          if (this.audioContext) {
              this.audioContext.close();
          }
      }
  }
  ```

#### 2.3 å®æ—¶çŠ¶æ€ç®¡ç†
**ç›®æ ‡**: å®ç°å®æ—¶å¯¹è¯çš„çŠ¶æ€ç®¡ç†å’ŒUIæ›´æ–°

**ä»»åŠ¡æ¸…å•**:
- [ ] **åˆ›å»ºå®æ—¶çŠ¶æ€ç®¡ç†å™¨**
  ```javascript
  // assets/js/realtime_state_manager.js
  class RealtimeStateManager {
      constructor() {
          this.STATES = {
              IDLE: 'idle',
              LISTENING: 'listening',
              PROCESSING: 'processing',
              SPEAKING: 'speaking',
              ERROR: 'error'
          };
          
          this.currentState = this.STATES.IDLE;
          this.conversationHistory = [];
          this.isMuted = false;
      }
      
      setState(newState) {
          this.currentState = newState;
          this.updateUI();
      }
      
      updateUI() {
          const statusElement = document.getElementById('realtime-status');
          const startBtn = document.getElementById('realtime-start-btn');
          const stopBtn = document.getElementById('realtime-stop-btn');
          const muteBtn = document.getElementById('realtime-mute-btn');
          
          switch (this.currentState) {
              case this.STATES.IDLE:
                  statusElement.innerHTML = '<span style="color: #666;">ç­‰å¾…å¼€å§‹å¯¹è¯</span>';
                  startBtn.disabled = false;
                  stopBtn.disabled = true;
                  break;
                  
              case this.STATES.LISTENING:
                  statusElement.innerHTML = '<span style="color: #ff4d4f;">ğŸ”´ æ­£åœ¨ç›‘å¬...</span>';
                  startBtn.disabled = true;
                  stopBtn.disabled = false;
                  break;
                  
              case this.STATES.PROCESSING:
                  statusElement.innerHTML = '<span style="color: #faad14;">ğŸŸ¡ å¤„ç†ä¸­...</span>';
                  startBtn.disabled = true;
                  stopBtn.disabled = true;
                  break;
                  
              case this.STATES.SPEAKING:
                  statusElement.innerHTML = '<span style="color: #52c41a;">ğŸŸ¢ AIæ­£åœ¨å›å¤...</span>';
                  startBtn.disabled = true;
                  stopBtn.disabled = true;
                  break;
                  
              case this.STATES.ERROR:
                  statusElement.innerHTML = '<span style="color: #ff4d4f;">âŒ å‘ç”Ÿé”™è¯¯</span>';
                  startBtn.disabled = false;
                  stopBtn.disabled = true;
                  break;
          }
      }
      
      addToHistory(speaker, text, timestamp) {
          this.conversationHistory.push({
              speaker,
              text,
              timestamp,
              id: Date.now()
          });
          this.updateHistoryDisplay();
      }
      
      updateHistoryDisplay() {
          const historyElement = document.getElementById('realtime-chat-history');
          historyElement.innerHTML = this.conversationHistory
              .map(entry => `
                  <div style="margin-bottom: 10px; padding: 8px; border-radius: 4px; 
                             background-color: ${entry.speaker === 'user' ? '#e6f7ff' : '#f6ffed'};">
                      <strong>${entry.speaker === 'user' ? 'ç”¨æˆ·' : 'AI'}:</strong>
                      <span>${entry.text}</span>
                      <small style="color: #666; float: right;">
                          ${new Date(entry.timestamp).toLocaleTimeString()}
                      </small>
                  </div>
              `).join('');
          
          // æ»šåŠ¨åˆ°åº•éƒ¨
          historyElement.scrollTop = historyElement.scrollHeight;
      }
  }
  ```

### Phase 3: ç³»ç»Ÿé›†æˆå’Œä¼˜åŒ– (ç¬¬5-6å‘¨)

#### 3.1 è¿æ¥æ± ç®¡ç†
**ç›®æ ‡**: å®ç°é«˜æ•ˆçš„WebSocketè¿æ¥ç®¡ç†

**ä»»åŠ¡æ¸…å•**:
- [ ] **åˆ›å»ºè¿æ¥æ± ç®¡ç†å™¨**
  ```python
  # core/connection_pool.py
  import asyncio
  from typing import Dict, Optional
  from dataclasses import dataclass
  from datetime import datetime, timedelta
  
  @dataclass
  class ConnectionInfo:
      websocket: WebSocket
      client_id: str
      connected_at: datetime
      last_activity: datetime
      is_active: bool = True
      audio_buffer: List[bytes] = None
      
      def __post_init__(self):
          if self.audio_buffer is None:
              self.audio_buffer = []
  
  class ConnectionPool:
      def __init__(self, max_connections: int = 100, 
                   connection_timeout: int = 300):
          self.max_connections = max_connections
          self.connection_timeout = connection_timeout
          self.connections: Dict[str, ConnectionInfo] = {}
          self.cleanup_task = None
      
      async def add_connection(self, websocket: WebSocket, client_id: str):
          """æ·»åŠ æ–°è¿æ¥"""
          if len(self.connections) >= self.max_connections:
              await self._cleanup_inactive_connections()
              
          if len(self.connections) >= self.max_connections:
              raise Exception("è¿æ¥æ± å·²æ»¡")
          
          self.connections[client_id] = ConnectionInfo(
              websocket=websocket,
              client_id=client_id,
              connected_at=datetime.now(),
              last_activity=datetime.now()
          )
          
          # å¯åŠ¨æ¸…ç†ä»»åŠ¡ï¼ˆå¦‚æœæœªå¯åŠ¨ï¼‰
          if not self.cleanup_task:
              self.cleanup_task = asyncio.create_task(self._periodic_cleanup())
      
      async def remove_connection(self, client_id: str):
          """ç§»é™¤è¿æ¥"""
          if client_id in self.connections:
              connection = self.connections[client_id]
              connection.is_active = False
              del self.connections[client_id]
      
      async def update_activity(self, client_id: str):
          """æ›´æ–°è¿æ¥æ´»åŠ¨æ—¶é—´"""
          if client_id in self.connections:
              self.connections[client_id].last_activity = datetime.now()
      
      async def get_connection(self, client_id: str) -> Optional[ConnectionInfo]:
          """è·å–è¿æ¥ä¿¡æ¯"""
          return self.connections.get(client_id)
      
      async def _cleanup_inactive_connections(self):
          """æ¸…ç†éæ´»è·ƒè¿æ¥"""
          now = datetime.now()
          inactive_connections = []
          
          for client_id, connection in self.connections.items():
              if (now - connection.last_activity).seconds > self.connection_timeout:
                  inactive_connections.append(client_id)
          
          for client_id in inactive_connections:
              await self.remove_connection(client_id)
              log.info(f"æ¸…ç†éæ´»è·ƒè¿æ¥: {client_id}")
      
      async def _periodic_cleanup(self):
          """å®šæœŸæ¸…ç†ä»»åŠ¡"""
          while True:
              await asyncio.sleep(60)  # æ¯åˆ†é’Ÿæ¸…ç†ä¸€æ¬¡
              await self._cleanup_inactive_connections()
  ```

#### 3.2 é”™è¯¯æ¢å¤æœºåˆ¶
**ç›®æ ‡**: å®ç°è‡ªåŠ¨é”™è¯¯æ¢å¤å’Œé‡è¿æœºåˆ¶

**ä»»åŠ¡æ¸…å•**:
- [ ] **åˆ›å»ºé”™è¯¯æ¢å¤ç®¡ç†å™¨**
  ```python
  # core/error_recovery.py
  import asyncio
  import time
  from typing import Dict, Optional
  
  class ErrorRecoveryManager:
      def __init__(self, max_retries: int = 3, retry_delay: float = 1.0):
          self.max_retries = max_retries
          self.retry_delay = retry_delay
          self.retry_counts = {}  # client_id -> retry_count
          self.recovery_tasks = {}  # client_id -> task
      
      async def handle_connection_error(self, client_id: str, error: Exception):
          """å¤„ç†è¿æ¥é”™è¯¯"""
          log.error(f"è¿æ¥é”™è¯¯: {client_id}, é”™è¯¯: {error}")
          
          # å¢åŠ é‡è¯•è®¡æ•°
          if client_id not in self.retry_counts:
              self.retry_counts[client_id] = 0
          
          self.retry_counts[client_id] += 1
          
          if self.retry_counts[client_id] <= self.max_retries:
              # å¯åŠ¨æ¢å¤ä»»åŠ¡
              if client_id not in self.recovery_tasks:
                  self.recovery_tasks[client_id] = asyncio.create_task(
                      self._attempt_recovery(client_id)
                  )
          else:
              # è¶…è¿‡æœ€å¤§é‡è¯•æ¬¡æ•°
              await self._handle_permanent_failure(client_id)
      
      async def _attempt_recovery(self, client_id: str):
          """å°è¯•æ¢å¤è¿æ¥"""
          try:
              # ç­‰å¾…é‡è¯•å»¶è¿Ÿ
              await asyncio.sleep(self.retry_delay)
              
              # å°è¯•é‡æ–°å»ºç«‹è¿æ¥
              await self._reconnect_client(client_id)
              
              # æ¢å¤æˆåŠŸï¼Œé‡ç½®é‡è¯•è®¡æ•°
              self.retry_counts[client_id] = 0
              
          except Exception as e:
              log.error(f"æ¢å¤å¤±è´¥: {client_id}, é”™è¯¯: {e}")
              # ç»§ç»­é‡è¯•æˆ–æ ‡è®°ä¸ºæ°¸ä¹…å¤±è´¥
              if self.retry_counts[client_id] < self.max_retries:
                  await self.handle_connection_error(client_id, e)
              else:
                  await self._handle_permanent_failure(client_id)
          finally:
              # æ¸…ç†æ¢å¤ä»»åŠ¡
              if client_id in self.recovery_tasks:
                  del self.recovery_tasks[client_id]
      
      async def _reconnect_client(self, client_id: str):
          """é‡æ–°è¿æ¥å®¢æˆ·ç«¯"""
          # å®ç°é‡è¿é€»è¾‘
          # 1. æ¸…ç†æ—§è¿æ¥
          # 2. å»ºç«‹æ–°è¿æ¥
          # 3. æ¢å¤çŠ¶æ€
          pass
      
      async def _handle_permanent_failure(self, client_id: str):
          """å¤„ç†æ°¸ä¹…å¤±è´¥"""
          log.error(f"å®¢æˆ·ç«¯æ°¸ä¹…å¤±è´¥: {client_id}")
          # æ¸…ç†èµ„æº
          # é€šçŸ¥ç”¨æˆ·
          pass
  ```

#### 3.3 æ€§èƒ½ç›‘æ§
**ç›®æ ‡**: å®ç°ç³»ç»Ÿæ€§èƒ½ç›‘æ§å’Œä¼˜åŒ–

**ä»»åŠ¡æ¸…å•**:
- [ ] **åˆ›å»ºæ€§èƒ½ç›‘æ§å™¨**
  ```python
  # monitoring/voice_performance_monitor.py
  import time
  import psutil
  from collections import deque
  from typing import Dict, List
  
  class VoicePerformanceMonitor:
      def __init__(self, max_samples: int = 1000):
          self.max_samples = max_samples
          self.metrics = {
              'audio_processing_time': deque(maxlen=max_samples),
              'tts_generation_time': deque(maxlen=max_samples),
              'connection_count': 0,
              'memory_usage': deque(maxlen=max_samples),
              'cpu_usage': deque(maxlen=max_samples),
              'error_count': 0
          }
          self.start_times = {}  # client_id -> start_time
      
      def start_audio_processing(self, client_id: str):
          """å¼€å§‹éŸ³é¢‘å¤„ç†è®¡æ—¶"""
          self.start_times[client_id] = time.time()
      
      def end_audio_processing(self, client_id: str):
          """ç»“æŸéŸ³é¢‘å¤„ç†è®¡æ—¶"""
          if client_id in self.start_times:
              duration = time.time() - self.start_times[client_id]
              self.metrics['audio_processing_time'].append(duration)
              del self.start_times[client_id]
      
      def record_tts_time(self, duration: float):
          """è®°å½•TTSç”Ÿæˆæ—¶é—´"""
          self.metrics['tts_generation_time'].append(duration)
      
      def update_connection_count(self, count: int):
          """æ›´æ–°è¿æ¥æ•°"""
          self.metrics['connection_count'] = count
      
      def record_error(self):
          """è®°å½•é”™è¯¯"""
          self.metrics['error_count'] += 1
      
      def update_system_metrics(self):
          """æ›´æ–°ç³»ç»ŸæŒ‡æ ‡"""
          self.metrics['memory_usage'].append(psutil.virtual_memory().percent)
          self.metrics['cpu_usage'].append(psutil.cpu_percent())
      
      def get_performance_summary(self) -> Dict:
          """è·å–æ€§èƒ½æ‘˜è¦"""
          def avg(values):
              return sum(values) / len(values) if values else 0
          
          return {
              'avg_audio_processing_time': avg(self.metrics['audio_processing_time']),
              'avg_tts_generation_time': avg(self.metrics['tts_generation_time']),
              'connection_count': self.metrics['connection_count'],
              'avg_memory_usage': avg(self.metrics['memory_usage']),
              'avg_cpu_usage': avg(self.metrics['cpu_usage']),
              'error_count': self.metrics['error_count']
          }
  ```

### Phase 4: æµ‹è¯•å’Œä¼˜åŒ– (ç¬¬7-8å‘¨)

#### 4.1 åŠŸèƒ½æµ‹è¯•
**ç›®æ ‡**: å…¨é¢æµ‹è¯•å®æ—¶è¯­éŸ³å¯¹è¯åŠŸèƒ½

**ä»»åŠ¡æ¸…å•**:
- [ ] **åˆ›å»ºæµ‹è¯•å¥—ä»¶**
  ```python
  # tests/test_realtime_voice.py
  import pytest
  import asyncio
  from unittest.mock import Mock, patch
  
  class TestRealtimeVoice:
      @pytest.fixture
      async def setup_test_environment(self):
          """è®¾ç½®æµ‹è¯•ç¯å¢ƒ"""
          # æ¨¡æ‹ŸWebSocketè¿æ¥
          # æ¨¡æ‹ŸéŸ³é¢‘æ•°æ®
          # æ¨¡æ‹ŸAIå“åº”
          pass
      
      async def test_voice_activity_detection(self):
          """æµ‹è¯•è¯­éŸ³æ´»åŠ¨æ£€æµ‹"""
          # æµ‹è¯•VADæ£€æµ‹å‡†ç¡®æ€§
          # æµ‹è¯•ä¸åŒéŸ³é¢‘è´¨é‡
          # æµ‹è¯•å™ªå£°ç¯å¢ƒ
          pass
      
      async def test_audio_stream_processing(self):
          """æµ‹è¯•éŸ³é¢‘æµå¤„ç†"""
          # æµ‹è¯•éŸ³é¢‘ç¼“å†²
          # æµ‹è¯•åˆ†æ®µå¤„ç†
          # æµ‹è¯•å¹¶å‘å¤„ç†
          pass
      
      async def test_realtime_response(self):
          """æµ‹è¯•å®æ—¶å“åº”"""
          # æµ‹è¯•ç«¯åˆ°ç«¯å»¶è¿Ÿ
          # æµ‹è¯•å“åº”è´¨é‡
          # æµ‹è¯•é”™è¯¯å¤„ç†
          pass
      
      async def test_connection_management(self):
          """æµ‹è¯•è¿æ¥ç®¡ç†"""
          # æµ‹è¯•è¿æ¥æ± 
          # æµ‹è¯•é”™è¯¯æ¢å¤
          # æµ‹è¯•èµ„æºæ¸…ç†
          pass
  ```

#### 4.2 æ€§èƒ½æµ‹è¯•
**ç›®æ ‡**: æµ‹è¯•ç³»ç»Ÿæ€§èƒ½å’Œç¨³å®šæ€§

**ä»»åŠ¡æ¸…å•**:
- [ ] **åˆ›å»ºæ€§èƒ½æµ‹è¯•è„šæœ¬**
  ```python
  # tests/performance/test_voice_load.py
  import asyncio
  import time
  import statistics
  from concurrent.futures import ThreadPoolExecutor
  
  class VoiceLoadTester:
      def __init__(self, max_concurrent: int = 50):
          self.max_concurrent = max_concurrent
          self.results = []
      
      async def test_concurrent_connections(self):
          """æµ‹è¯•å¹¶å‘è¿æ¥"""
          tasks = []
          for i in range(self.max_concurrent):
              task = asyncio.create_task(self._simulate_voice_session(f"client_{i}"))
              tasks.append(task)
          
          results = await asyncio.gather(*tasks, return_exceptions=True)
          self._analyze_results(results)
      
      async def _simulate_voice_session(self, client_id: str):
          """æ¨¡æ‹Ÿè¯­éŸ³ä¼šè¯"""
          start_time = time.time()
          
          try:
              # æ¨¡æ‹Ÿè¿æ¥å»ºç«‹
              # æ¨¡æ‹ŸéŸ³é¢‘å‘é€
              # æ¨¡æ‹Ÿå“åº”æ¥æ”¶
              # æ¨¡æ‹Ÿä¼šè¯ç»“æŸ
              
              duration = time.time() - start_time
              return {
                  'client_id': client_id,
                  'duration': duration,
                  'success': True
              }
          except Exception as e:
              return {
                  'client_id': client_id,
                  'error': str(e),
                  'success': False
              }
      
      def _analyze_results(self, results):
          """åˆ†ææµ‹è¯•ç»“æœ"""
          successful = [r for r in results if r.get('success', False)]
          failed = [r for r in results if not r.get('success', False)]
          
          durations = [r['duration'] for r in successful]
          
          print(f"æˆåŠŸä¼šè¯: {len(successful)}")
          print(f"å¤±è´¥ä¼šè¯: {len(failed)}")
          print(f"å¹³å‡å»¶è¿Ÿ: {statistics.mean(durations):.2f}ç§’")
          print(f"æœ€å¤§å»¶è¿Ÿ: {max(durations):.2f}ç§’")
          print(f"æœ€å°å»¶è¿Ÿ: {min(durations):.2f}ç§’")
  ```

---

## ğŸ“Š å®æ–½æ—¶é—´è¡¨

### ç¬¬1-2å‘¨: åç«¯å®æ—¶éŸ³é¢‘æµå¤„ç†
- [ ] å®ç°VADè¯­éŸ³æ´»åŠ¨æ£€æµ‹
- [ ] å®ç°éŸ³é¢‘æµç¼“å†²ç®¡ç†
- [ ] å®ç°å¹¶è¡ŒéŸ³é¢‘å¤„ç†
- [ ] ä¼˜åŒ–ä½å»¶è¿Ÿå“åº”

### ç¬¬3-4å‘¨: å‰ç«¯å®æ—¶å¯¹è¯ç•Œé¢
- [ ] åˆ›å»ºå®æ—¶å¯¹è¯ç»„ä»¶
- [ ] å®ç°éŸ³é¢‘å¯è§†åŒ–
- [ ] å®ç°å®æ—¶çŠ¶æ€ç®¡ç†
- [ ] é›†æˆç°æœ‰è¯­éŸ³åŠŸèƒ½

### ç¬¬5-6å‘¨: ç³»ç»Ÿé›†æˆå’Œä¼˜åŒ–
- [ ] å®ç°è¿æ¥æ± ç®¡ç†
- [ ] å®ç°é”™è¯¯æ¢å¤æœºåˆ¶
- [ ] å®ç°æ€§èƒ½ç›‘æ§
- [ ] ä¼˜åŒ–ç³»ç»Ÿç¨³å®šæ€§

### ç¬¬7-8å‘¨: æµ‹è¯•å’Œä¼˜åŒ–
- [ ] åŠŸèƒ½æµ‹è¯•
- [ ] æ€§èƒ½æµ‹è¯•
- [ ] ç”¨æˆ·ä½“éªŒæµ‹è¯•
- [ ] ç³»ç»Ÿä¼˜åŒ–

---

## ğŸ¯ æˆåŠŸæ ‡å‡†

### æŠ€æœ¯æŒ‡æ ‡
- **éŸ³é¢‘å»¶è¿Ÿ**: < 2ç§’ (ä»å½•éŸ³åˆ°æ’­æ”¾)
- **è¿æ¥ç¨³å®šæ€§**: > 99% å¯ç”¨æ€§
- **å¹¶å‘æ”¯æŒ**: 50+ åŒæ—¶è¿æ¥
- **é”™è¯¯æ¢å¤**: < 5ç§’è‡ªåŠ¨æ¢å¤

### ç”¨æˆ·ä½“éªŒ
- **ç›´è§‚çš„ç•Œé¢**: æ¸…æ™°çš„å®æ—¶çŠ¶æ€æŒ‡ç¤º
- **æµç•…çš„äº¤äº’**: æ— å¡é¡¿çš„è¯­éŸ³å¯¹è¯
- **ç¨³å®šçš„è¿æ¥**: è‡ªåŠ¨é”™è¯¯æ¢å¤
- **é«˜è´¨é‡éŸ³é¢‘**: æ¸…æ™°çš„è¯­éŸ³è¯†åˆ«å’Œåˆæˆ

### ç³»ç»Ÿæ€§èƒ½
- **å†…å­˜ä½¿ç”¨**: < 2GB å³°å€¼å†…å­˜
- **CPUä½¿ç”¨**: < 80% å¹³å‡CPU
- **ç½‘ç»œå¸¦å®½**: < 1Mbps æ¯è¿æ¥
- **å“åº”æ—¶é—´**: < 100ms APIå“åº”

---

## ğŸš¨ é£é™©æ§åˆ¶

### æŠ€æœ¯é£é™©
- **éŸ³é¢‘å¤„ç†å»¶è¿Ÿ**: å®ç°æ€§èƒ½ç›‘æ§å’Œä¼˜åŒ–
- **è¿æ¥ç¨³å®šæ€§**: å®ç°é‡è¿æœºåˆ¶å’Œé”™è¯¯æ¢å¤
- **å†…å­˜ä½¿ç”¨**: å®ç°èµ„æºç›‘æ§å’Œé™åˆ¶
- **å¹¶å‘å¤„ç†**: å®ç°è¿æ¥æ± å’Œè´Ÿè½½å‡è¡¡

### ç¼“è§£æªæ–½
- æ¯ä¸ªé˜¶æ®µå®Œæˆåè¿›è¡Œä»£ç å®¡æŸ¥
- å…³é”®åŠŸèƒ½å®ç°åç«‹å³æµ‹è¯•
- å®šæœŸè¿›è¡Œæ€§èƒ½åŸºå‡†æµ‹è¯•
- å»ºç«‹å›æ»šæœºåˆ¶å’Œç›‘æ§å‘Šè­¦

---

**è´Ÿè´£äºº**: è¯­éŸ³åŠŸèƒ½å¼€å‘å›¢é˜Ÿ  
**é¢„è®¡å®Œæˆæ—¶é—´**: 8å‘¨  
**èµ„æºéœ€æ±‚**: 2-3åå¼€å‘äººå‘˜ï¼Œ1åæµ‹è¯•äººå‘˜ï¼Œ1åUI/UXè®¾è®¡å¸ˆ
